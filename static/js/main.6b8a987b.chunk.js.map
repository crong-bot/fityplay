{"version":3,"sources":["lexer.js","generate.js","Editor.js","components/LogsContainer.js","App.js","index.js","components/Transcompile.js","small.js","components/prefunc.js"],"names":["indentifiedLexer","require","compile","ws","nl","match","lineBreaks","comment","number","string","iterator","operator","calculator","lparen","rparen","lbracke","rbracke","lbrace","rbrace","identifier","fatarrow","assign","keyword","module","exports","tp","node","type","statements","map","d","join","varName","var_name","value","jsExpr","funName","fun_name","arg_list","arguments","arg","has_middle_condition","has_last_statement","first_condition","first_statement","middle_condition","i","middle_statement","last_statement","arrayname","array_name","array_value","a","b","statement","console","log","Editor","props","language","onChange","className","onBeforeChange","editor","data","options","lint","lineNumbers","mode","lineWrapping","theme","LogsContainer","useState","logs","setLogs","useEffect","Hook","window","currLogs","Unhook","variant","filter","styles","BASE_BACKGROUND_COLOR","BASE_FONT_SIZE","LOG_ERROR_BACKGROUND","LOG_WARN_BACKGROUND","LOG_INFO_BACKGROUND","searchKeywords","App","code","setCode","ab","setAb","onClick","Transcompile","ReactDOM","render","document","getElementById","nearley","generate","default","database","setDatabase","chartdatas","setChartdatas","keys","values","labels","parser","Parser","Grammar","fromCompiled","grammar","feed","parserResult","results","undefined","line","lines","concat","fityfunc","ww","가람시","eval","e","newerror","reportError","message","info","includes","replace","datasets","label","fill","borderColor","React","memo","id","x","mylexer","Lexer","ParserRules","name","symbols","postprocess","has","literal","eol","indent","dedent","has_last_condition","v","ParserStart","prefunc"],"mappings":"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","file":"static/js/main.6b8a987b.chunk.js","sourcesContent":["const IndentifyLexer = require('@shieldsbetter/nearley-indentify');\r\n\r\nconst indentifiedLexer = new IndentifyLexer(mooLexer());\r\n\r\nfunction mooLexer() {\r\n  return require('moo').compile({\r\n    ws: /[ \\t]+/,\r\n    nl: { match: /\\n/, lineBreaks: true },\r\n    comment: /\\/\\/.*?$/,\r\n    number: /0|[1-9][0-9]*/,\r\n    string: /\"(?:\\\\[\"\\\\]|[^\\n\"\\\\])*\"/,\r\n    iterator: '<-',\r\n    operator: ['==', '>=', '<=', '!=', '>', '<', '.', ','],\r\n    calculator: ['+', '-', '*', '/', '++', '--'],\r\n    lparen: '(',\r\n    rparen: ')',\r\n    lbracke: '[',\r\n    rbracke: ']',\r\n    lbrace: '{',\r\n    rbrace: '}',\r\n    identifier: /[a-zA-Z가-힣][a-zA-Z가-힣_0-9]*/,\r\n    fatarrow: '=>',\r\n    assign: '=',\r\n    keyword: ['만약', '반복'],\r\n  });\r\n}\r\n\r\n/* indentifiedLexer.reset(`\r\n    Hello World\r\n        Heres some\r\n        indentation\r\n    And dedentation\r\n`);\r\n\r\nlet token = indentifiedLexer.next();\r\nwhile (token) {\r\n  console.log({ type: token.type, value: token.value });\r\n\r\n  token = indentifiedLexer.next();\r\n} */\r\n\r\nmodule.exports = indentifiedLexer;\r\n\r\n/* async function main() {\r\n  //prettier-ignore\r\n  const code = (await fs.readFile(\"ex2.small\")).toString();\r\n  lexer.reset(code);\r\n  while (true) {\r\n    const token = lexer.next();\r\n    if (!token) {\r\n      break;\r\n    }\r\n    console.log(token);\r\n  }\r\n}\r\n\r\nmain().catch((err) => console.log(err.stack)); */\r\n","function generateJsForStatements(statements) {\r\n  const lines = [];\r\n  for (let statement of statements) {\r\n    const line = tp(statement);\r\n    lines.push(line);\r\n  }\r\n  return lines.join('\\n');\r\n}\r\nfunction tp(node) {\r\n  if (node.type === 'closure') {\r\n    return `${node.statements.map((d) => tp(d)).join('\\n')}`;\r\n  } else if (node.type === 'var_assign') {\r\n    const varName = node.var_name.value;\r\n    const jsExpr = tp(node.value);\r\n    const js = `var ${varName} = ${jsExpr}`;\r\n    return js;\r\n  } else if (node.type === 'fun_call') {\r\n    const funName = node.fun_name.value;\r\n    const arg_list = node.arguments\r\n      .map((arg) => {\r\n        return tp(arg);\r\n      })\r\n      .join(',');\r\n    return `${funName}(${arg_list})`;\r\n  } else if (node.type === 'ifstate') {\r\n    if (node.has_middle_condition && node.has_last_statement) {\r\n      return `if(${tp(node.first_condition)}) {\r\n      ${tp(...node.first_statement)}}\r\n      ${node.middle_condition\r\n        .map((d, i) => `else if(${tp(d)}) {${tp(...node.middle_statement[i])}}`)\r\n        .join('\\n')}\r\n      else {${tp(...node.last_statement)}}\r\n      `;\r\n    } else if (node.has_middle_condition && !node.has_last_statement) {\r\n      return `if(${tp(node.first_condition)}) {\r\n      ${tp(...node.first_statement)}}\r\n      ${node.middle_condition\r\n        .map((d, i) => `else if(${tp(d)}) {${tp(...node.middle_statement[i])}}`)\r\n        .join('\\n')}`;\r\n    } else if (!node.has_middle_condition && node.has_last_statement) {\r\n      return `if(${tp(node.first_condition)}) {\r\n      ${tp(...node.first_statement)}}\r\n      else {${tp(...node.last_statement)}}`;\r\n    } else {\r\n      return `if(${tp(node.first_condition)}) {\r\n      ${tp(...node.first_statement)}}`;\r\n    }\r\n  } else if (node.type === 'condition') {\r\n    return node.value.map((d) => tp(d)).join('');\r\n  } else if (node.type === 'array') {\r\n    const arrayname = node.array_name.value;\r\n    return `var ${arrayname}=[${node.array_value\r\n      .map((d) => {\r\n        return tp(d);\r\n      })\r\n      .join(',')}]`;\r\n  } else if (node.type === 'for_block') {\r\n    const a = node.a.value;\r\n    const b = node.b.value;\r\n    return `for (var ${a} in ${b}) {${tp(...node.statement)} };`;\r\n  } else if (node.type === 'return') {\r\n    return node.value;\r\n  } else if (node.type === 'operator') {\r\n    return node.value;\r\n  } else if (node.type === 'string') {\r\n    return node.value;\r\n  } else if (node.type === 'number') {\r\n    return node.value;\r\n  } else if (node.type === 'identifier') {\r\n    return node.value;\r\n  } else if (node.type === 'calculator') {\r\n    return node.value;\r\n  } else {\r\n    console.log('문법이 틀렸어요...');\r\n    /* throw new Error(`unhandled ast node type 11`); */\r\n  }\r\n}\r\n\r\nexport default tp;\r\n","import React, { useState } from 'react';\r\nimport 'codemirror/lib/codemirror.css';\r\nimport 'codemirror/theme/material.css';\r\nimport 'codemirror/theme/dracula.css';\r\nimport 'codemirror/mode/xml/xml';\r\nimport 'codemirror/mode/javascript/javascript';\r\nimport 'codemirror/mode/python/python';\r\nimport { Controlled as ControlledEditor } from 'react-codemirror2';\r\n\r\nfunction Editor(props) {\r\n  const { language, value, onChange } = props;\r\n  function handlechange(editor, data, value) {\r\n    onChange(value);\r\n  }\r\n  return (\r\n    <>\r\n      <div className=\"editor_container\">\r\n        <ControlledEditor\r\n          className=\"editor\"\r\n          onBeforeChange={handlechange}\r\n          value={value}\r\n          options={{\r\n            lint: true,\r\n            lineNumbers: true,\r\n            mode: language,\r\n            lineWrapping: true,\r\n            theme: 'dracula',\r\n          }}\r\n        />\r\n      </div>\r\n    </>\r\n  );\r\n}\r\n\r\nexport default Editor;\r\n","import React, { useState, useEffect } from 'react';\r\nimport { Console, Hook, Unhook } from 'console-feed';\r\n\r\nconst LogsContainer = () => {\r\n  const [logs, setLogs] = useState([]);\r\n\r\n  const consoleStyles = {\r\n    BASE_BACKGROUND_COLOR: 'none',\r\n    BASE_FONT_SIZE: '1.2rem',\r\n    LOG_ERROR_BACKGROUND: 'rgba(255,0,0,.1)',\r\n    LOG_WARN_BACKGROUND: 'rgba(255,255,0,.1)',\r\n    LOG_INFO_BACKGROUND: 'rgba(0,0,255,.1)',\r\n  };\r\n  // run once!\r\n  useEffect(() => {\r\n    Hook(\r\n      window.console,\r\n      (log) => setLogs((currLogs) => [...currLogs, log]),\r\n      false\r\n    );\r\n    return () => Unhook(window.console);\r\n  }, []);\r\n\r\n  return (\r\n    <>\r\n      <Console\r\n        logs={logs}\r\n        variant=\"dark\"\r\n        filter=\"Methods[log,info]\"\r\n        styles={consoleStyles}\r\n        searchKeywords=\"\"\r\n      />\r\n    </>\r\n  );\r\n};\r\n\r\nexport default LogsContainer;\r\n","import Editor from './Editor.js';\nimport React, { useState, useEffect } from 'react';\nimport LogsContainer from './components/LogsContainer.js';\nimport Transcompile from './components/Transcompile.js';\n\n/* const grammar = require('./small.js'); */\n\nfunction App() {\n  const [code, setCode] = useState('');\n  const [ab, setAb] = useState('');\n  function sendcode() {\n    setAb(code);\n  }\n  return (\n    <>\n      <div className=\"panel\">\n        <h1 className=\"title\"> fitycode PLAYGROUND</h1>\n        <div className=\"left_pane\">\n          <button className=\"run_btn\" onClick={sendcode}>\n            RUN\n          </button>\n          <Editor language=\"python\" value={code} onChange={setCode} />\n        </div>\n        <div className=\"center_pane\">\n          <div className=\"data_pane\">\n            <Transcompile value={ab} />\n          </div>\n          <div className=\"console_pane\">\n            <LogsContainer />\n          </div>\n        </div>\n        <div className=\"right_pane\"></div>\n      </div>\n    </>\n  );\n}\n\nexport default App;\n/*    <iframe\n            srcDoc={a}\n            title=\"output\"\n            frameBorder=\"0\"\n            sandbox=\"allow-scripts\"\n            width=\"100%\"\n            height=\"100%\"\n          /> */\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\n\nReactDOM.render(\n  //<React.StrictMode>\n  <App />,\n  // </React.StrictMode>,\n  document.getElementById('root')\n);\n","import React, { useState, useEffect } from 'react';\r\nimport Example1 from './Example1.js';\r\nimport grammar from '../small.js';\r\nimport { prefunc as fityfunc } from './prefunc.js';\r\nimport 가람시 from '../data/weatherData.json';\r\nimport { Line } from 'react-chartjs-2';\r\n\r\nconst nearley = require('nearley');\r\nconst generate = require('../generate.js').default;\r\n\r\nfunction Transcompile(props) {\r\n  const [database, setDatabase] = useState([]);\r\n  const [chartdatas, setChartdatas] = useState('');\r\n  let data = [];\r\n  let keys;\r\n  let values;\r\n  let labels = '차트제목';\r\n\r\n  useEffect(() => {\r\n    const parser = new nearley.Parser(nearley.Grammar.fromCompiled(grammar));\r\n    parser.feed(props.value);\r\n    const parserResult = parser.results;\r\n    if (parserResult[0] !== undefined) {\r\n      const line = generate(parserResult[0][0]);\r\n      const lines = line.concat('\\n', fityfunc);\r\n      try {\r\n        let ww = 가람시;\r\n        eval(lines);\r\n      } catch (e) {\r\n        const newerror = reportError(e.message);\r\n        console.info(newerror);\r\n      }\r\n    } else {\r\n      console.info('문법을 다시 확인해보세요');\r\n    }\r\n\r\n    function reportError(e) {\r\n      if (e.includes('defined') === true) {\r\n        const newerror = e.replace('is not defined', '는 정의되지 않았습니다.');\r\n        return newerror;\r\n      } else if (e.includes('undefined') === true) {\r\n        const newerror = e.replace('undefined', '바꿨다시발');\r\n        return newerror;\r\n      }\r\n    }\r\n    setChartdatas({\r\n      labels: keys,\r\n      datasets: [\r\n        /* {\r\n          label: 'First dataset',\r\n          data: [33, 53, 85, 41, 44, 65],\r\n          fill: true,\r\n          backgroundColor: 'rgba(75,192,192,0.2)',\r\n          borderColor: 'rgba(75,192,192,1)',\r\n        }, */\r\n        {\r\n          label: labels,\r\n          data: values,\r\n          fill: false,\r\n          borderColor: '#742774',\r\n        },\r\n      ],\r\n    });\r\n  }, [props.value]);\r\n\r\n  return (\r\n    <>\r\n      <Line data={chartdatas} />\r\n    </>\r\n  );\r\n}\r\nexport default React.memo(Transcompile);\r\n\r\n/* if (parserResult[0] != undefined) {\r\n      const line = generate(parserResult[0][0]);\r\n      const lines = line.concat('\\n', fityfunc);\r\n      eval(lines);\r\n    } else {\r\n      console.log('문법이 다시 살펴보세요(app.js)!');\r\n    } */\r\n\r\n/*     setA(`<html>\r\n      <body\r\n      \r\n      </body>\r\n      <script>console.log(\"a\")</script>\r\n    </html>`); */\r\n","/* eslint-disable no-undef */\r\n// Generated automatically by nearley, version 2.19.7\r\n// http://github.com/Hardmath123/nearley\r\n(function () {\r\n  function id(x) {\r\n    return x[0];\r\n  }\r\n\r\n  const mylexer = require('./lexer');\r\n  const wrapVariable = (name) => ({\r\n    label: 'atom',\r\n    type: 'variable',\r\n    value: name,\r\n  });\r\n  var grammar = {\r\n    Lexer: mylexer,\r\n    ParserRules: [\r\n      { name: 'statements', symbols: ['closure'], postprocess: id },\r\n      { name: 'closure$ebnf$1', symbols: [] },\r\n      {\r\n        name: 'closure$ebnf$1',\r\n        symbols: ['closure$ebnf$1', 'statement'],\r\n        postprocess: function arrpush(d) {\r\n          return d[0].concat([d[1]]);\r\n        },\r\n      },\r\n      {\r\n        name: 'closure',\r\n        symbols: ['closure$ebnf$1'],\r\n        postprocess: (data) => [\r\n          {\r\n            label: 'closure',\r\n            type: 'closure',\r\n            statements: data[0],\r\n          },\r\n        ],\r\n      },\r\n      { name: 'statement', symbols: ['var_assign', '_m'], postprocess: id },\r\n      { name: 'statement', symbols: ['fun_call', '_m'], postprocess: id },\r\n      { name: 'statement', symbols: ['if_state', '_m'], postprocess: id },\r\n      { name: 'statement', symbols: ['for_state', '_m'], postprocess: id },\r\n      { name: 'statement', symbols: ['return', '_m'], postprocess: id },\r\n      {\r\n        name: 'var_assign',\r\n        symbols: [\r\n          mylexer.has('identifier') ? { type: 'identifier' } : identifier,\r\n          '_',\r\n          { literal: '=' },\r\n          '_',\r\n          'expr',\r\n        ],\r\n        postprocess: (data) => {\r\n          return {\r\n            label: 'state',\r\n            type: 'var_assign',\r\n            var_name: data[0],\r\n            value: data[4],\r\n          };\r\n        },\r\n      },\r\n      {\r\n        name: 'var_assign',\r\n        symbols: [\r\n          mylexer.has('identifier') ? { type: 'identifier' } : identifier,\r\n          '_',\r\n          { literal: '=' },\r\n          '_',\r\n          'array',\r\n        ],\r\n        postprocess: (data) => {\r\n          return {\r\n            label: 'state',\r\n            type: 'array',\r\n            array_name: data[0],\r\n            array_value: data[4],\r\n          };\r\n        },\r\n      },\r\n      { name: 'fun_call$ebnf$1$subexpression$1', symbols: ['arg_list', '_'] },\r\n      {\r\n        name: 'fun_call$ebnf$1',\r\n        symbols: ['fun_call$ebnf$1$subexpression$1'],\r\n        postprocess: id,\r\n      },\r\n      {\r\n        name: 'fun_call$ebnf$1',\r\n        symbols: [],\r\n        postprocess: function (d) {\r\n          return null;\r\n        },\r\n      },\r\n      {\r\n        name: 'fun_call',\r\n        symbols: [\r\n          mylexer.has('identifier') ? { type: 'identifier' } : identifier,\r\n          '_',\r\n          { literal: '(' },\r\n          '_',\r\n          'fun_call$ebnf$1',\r\n          { literal: ')' },\r\n        ],\r\n        postprocess: (data) => {\r\n          return {\r\n            label: 'state',\r\n            type: 'fun_call',\r\n            fun_name: data[0],\r\n            arguments: data[4] ? data[4][0] : [],\r\n          };\r\n        },\r\n      },\r\n      {\r\n        name: 'if_state',\r\n        symbols: [\r\n          { literal: '만약' },\r\n          '_',\r\n          'condition',\r\n          mylexer.has('eol') ? { type: 'eol' } : eol,\r\n          mylexer.has('indent') ? { type: 'indent' } : indent,\r\n          'closure',\r\n        ],\r\n        postprocess: (data) => {\r\n          return {\r\n            label: 'state',\r\n            type: 'ifstate',\r\n            first_condition: data[2],\r\n            first_statement: [...data[5]],\r\n\r\n            has_middle_condition: false,\r\n            middle_statement: undefined,\r\n\r\n            has_last_statement: false,\r\n            last_statement: undefined,\r\n          };\r\n        },\r\n      },\r\n      {\r\n        name: 'if_state',\r\n        symbols: [\r\n          { literal: '만약' },\r\n          '_',\r\n          'condition',\r\n          mylexer.has('eol') ? { type: 'eol' } : eol,\r\n          mylexer.has('indent') ? { type: 'indent' } : indent,\r\n          'closure',\r\n          mylexer.has('dedent') ? { type: 'dedent' } : dedent,\r\n          { literal: '거짓' },\r\n          '_',\r\n          mylexer.has('eol') ? { type: 'eol' } : eol,\r\n          mylexer.has('indent') ? { type: 'indent' } : indent,\r\n          'closure',\r\n        ],\r\n        postprocess: (data) => {\r\n          return {\r\n            label: 'state',\r\n            type: 'ifstate',\r\n            first_condition: data[2],\r\n            first_statement: data[5],\r\n\r\n            has_middle_condition: false,\r\n            middle_statement: undefined,\r\n\r\n            has_last_statement: true,\r\n            last_statement: [...data[11]],\r\n          };\r\n        },\r\n      },\r\n      { name: 'if_state$ebnf$1', symbols: [] },\r\n      {\r\n        name: 'if_state$ebnf$1$subexpression$1',\r\n        symbols: [\r\n          { literal: '아니면' },\r\n          '_',\r\n          'condition',\r\n          mylexer.has('eol') ? { type: 'eol' } : eol,\r\n          mylexer.has('indent') ? { type: 'indent' } : indent,\r\n          'closure',\r\n          mylexer.has('dedent') ? { type: 'dedent' } : dedent,\r\n        ],\r\n      },\r\n      {\r\n        name: 'if_state$ebnf$1',\r\n        symbols: ['if_state$ebnf$1', 'if_state$ebnf$1$subexpression$1'],\r\n        postprocess: function arrpush(d) {\r\n          return d[0].concat([d[1]]);\r\n        },\r\n      },\r\n      {\r\n        name: 'if_state',\r\n        symbols: [\r\n          { literal: '만약' },\r\n          '_',\r\n          'condition',\r\n          mylexer.has('eol') ? { type: 'eol' } : eol,\r\n          mylexer.has('indent') ? { type: 'indent' } : indent,\r\n          'closure',\r\n          mylexer.has('dedent') ? { type: 'dedent' } : dedent,\r\n          'if_state$ebnf$1',\r\n          { literal: '아니면' },\r\n          '_',\r\n          'condition',\r\n          mylexer.has('eol') ? { type: 'eol' } : eol,\r\n          mylexer.has('indent') ? { type: 'indent' } : indent,\r\n          'closure',\r\n        ],\r\n        postprocess: (data) => {\r\n          return {\r\n            label: 'state',\r\n            type: 'ifstate',\r\n            first_condition: data[2],\r\n            first_statement: data[5],\r\n\r\n            has_middle_condition: true,\r\n            middle_condition: [...data[7].map((value) => value[2]), data[10]],\r\n            middle_statement: [...data[7].map((value) => value[5]), data[13]],\r\n\r\n            has_last_condition: false,\r\n            last_statement: undefined,\r\n          };\r\n        },\r\n      },\r\n      {\r\n        name: 'if_state$ebnf$2$subexpression$1',\r\n        symbols: [\r\n          { literal: '아니면' },\r\n          '_',\r\n          'condition',\r\n          mylexer.has('eol') ? { type: 'eol' } : eol,\r\n          mylexer.has('indent') ? { type: 'indent' } : indent,\r\n          'closure',\r\n          mylexer.has('dedent') ? { type: 'dedent' } : dedent,\r\n        ],\r\n      },\r\n      { name: 'if_state$ebnf$2', symbols: ['if_state$ebnf$2$subexpression$1'] },\r\n      {\r\n        name: 'if_state$ebnf$2$subexpression$2',\r\n        symbols: [\r\n          { literal: '아니면' },\r\n          '_',\r\n          'condition',\r\n          mylexer.has('eol') ? { type: 'eol' } : eol,\r\n          mylexer.has('indent') ? { type: 'indent' } : indent,\r\n          'closure',\r\n          mylexer.has('dedent') ? { type: 'dedent' } : dedent,\r\n        ],\r\n      },\r\n      {\r\n        name: 'if_state$ebnf$2',\r\n        symbols: ['if_state$ebnf$2', 'if_state$ebnf$2$subexpression$2'],\r\n        postprocess: function arrpush(d) {\r\n          return d[0].concat([d[1]]);\r\n        },\r\n      },\r\n      {\r\n        name: 'if_state',\r\n        symbols: [\r\n          { literal: '만약' },\r\n          '_',\r\n          'condition',\r\n          mylexer.has('eol') ? { type: 'eol' } : eol,\r\n          mylexer.has('indent') ? { type: 'indent' } : indent,\r\n          'closure',\r\n          mylexer.has('dedent') ? { type: 'dedent' } : dedent,\r\n          'if_state$ebnf$2',\r\n          { literal: '거짓' },\r\n          '_',\r\n          mylexer.has('eol') ? { type: 'eol' } : eol,\r\n          mylexer.has('indent') ? { type: 'indent' } : indent,\r\n          'closure',\r\n        ],\r\n        postprocess: (data) => {\r\n          return {\r\n            label: 'state',\r\n            type: 'ifstate',\r\n            first_condition: data[2],\r\n            first_statement: data[5],\r\n\r\n            has_middle_condition: true,\r\n            middle_condition: [...data[7].map((value) => value[2])],\r\n            middle_statement: [...data[7].map((value) => value[5])],\r\n\r\n            has_last_statement: true,\r\n            last_statement: [...data[12]],\r\n          };\r\n        },\r\n      },\r\n      {\r\n        name: 'condition',\r\n        symbols: [\r\n          'expr',\r\n          '_',\r\n          mylexer.has('operator') ? { type: 'operator' } : operator,\r\n          '_',\r\n          'expr',\r\n        ],\r\n        postprocess: (data) => {\r\n          return {\r\n            type: 'condition',\r\n            value: [data[0], data[2], data[4]],\r\n          };\r\n        },\r\n      },\r\n      {\r\n        name: 'arg_list',\r\n        symbols: ['expr'],\r\n        postprocess: (data) => {\r\n          return [data[0]];\r\n        },\r\n      },\r\n      {\r\n        name: 'arg_list',\r\n        symbols: ['arg_list', '__', 'expr'],\r\n        postprocess: (data) => {\r\n          return [...data[0], data[2]];\r\n        },\r\n      },\r\n      { name: 'array$ebnf$1', symbols: [] },\r\n      {\r\n        name: 'array$ebnf$1$subexpression$1',\r\n        symbols: [{ literal: ',' }, '_', 'expr'],\r\n      },\r\n      {\r\n        name: 'array$ebnf$1',\r\n        symbols: ['array$ebnf$1', 'array$ebnf$1$subexpression$1'],\r\n        postprocess: function arrpush(d) {\r\n          return d[0].concat([d[1]]);\r\n        },\r\n      },\r\n      {\r\n        name: 'array',\r\n        symbols: [\r\n          { literal: '[' },\r\n          '_',\r\n          'expr',\r\n          '_',\r\n          'array$ebnf$1',\r\n          '_',\r\n          { literal: ']' },\r\n        ],\r\n        postprocess: (data) => {\r\n          return [data[2], ...data[4].map((v) => v[2])];\r\n        },\r\n      },\r\n      {\r\n        name: 'expr',\r\n        symbols: [mylexer.has('string') ? { type: 'string' } : string],\r\n        postprocess: id,\r\n      },\r\n      {\r\n        name: 'expr',\r\n        symbols: [\r\n          mylexer.has('identifier') ? { type: 'identifier' } : identifier,\r\n        ],\r\n        postprocess: id,\r\n      },\r\n      { name: 'expr', symbols: ['fun_call'], postprocess: id },\r\n      { name: 'expr', symbols: ['AS'], postprocess: id },\r\n      {\r\n        name: 'for_state',\r\n        symbols: [\r\n          { literal: '반복' },\r\n          '__',\r\n          'expr',\r\n          '_',\r\n          mylexer.has('iterator') ? { type: 'iterator' } : iterator,\r\n          '_',\r\n          'expr',\r\n          mylexer.has('eol') ? { type: 'eol' } : eol,\r\n          mylexer.has('indent') ? { type: 'indent' } : indent,\r\n          'closure',\r\n        ],\r\n        postprocess: (data) => {\r\n          return {\r\n            label: 'statement',\r\n            type: 'for_block',\r\n            a: data[2],\r\n            iterator: data[4],\r\n            b: data[6],\r\n            statement: data[9],\r\n          };\r\n        },\r\n      },\r\n      {\r\n        name: 'return',\r\n        symbols: [{ literal: '출력' }, '_', 'expr'],\r\n        postprocess: (d) => {\r\n          return { type: 'return', value: d[2] };\r\n        },\r\n      },\r\n      {\r\n        name: 'P',\r\n        symbols: [{ literal: '(' }, '_', 'AS', '_', { literal: ')' }],\r\n        postprocess: (d) => {\r\n          return d[2];\r\n        },\r\n      },\r\n      { name: 'P', symbols: ['number'], postprocess: id },\r\n      { name: 'MD', symbols: ['P'], postprocess: id },\r\n      {\r\n        name: 'MD',\r\n        symbols: ['MD', '_', { literal: '*' }, '_', 'P'],\r\n        postprocess: (d) => {\r\n          return [d[0], d[2], d[4]];\r\n        },\r\n      },\r\n      {\r\n        name: 'MD',\r\n        symbols: ['MD', '_', { literal: '/' }, '_', 'P'],\r\n        postprocess: (d) => {\r\n          return [d[0], d[2], d[4]];\r\n        },\r\n      },\r\n      { name: 'AS', symbols: ['MD'], postprocess: id },\r\n      {\r\n        name: 'AS',\r\n        symbols: ['AS', '_', { literal: '+' }, '_', 'MD'],\r\n        postprocess: (d) => {\r\n          return [d[0], d[2], d[4]];\r\n        },\r\n      },\r\n      {\r\n        name: 'AS',\r\n        symbols: ['AS', '_', { literal: '-' }, '_', 'MD'],\r\n        postprocess: (d) => {\r\n          return [d[0], d[2], d[4]];\r\n        },\r\n      },\r\n      {\r\n        name: 'cal',\r\n        symbols: [\r\n          mylexer.has('calculator') ? { type: 'calculator' } : calculator,\r\n        ],\r\n        postprocess: id,\r\n      },\r\n      {\r\n        name: 'number',\r\n        symbols: [mylexer.has('number') ? { type: 'number' } : number],\r\n        postprocess: id,\r\n      },\r\n      { name: 'number', symbols: ['float'], postprocess: id },\r\n      {\r\n        name: 'float',\r\n        symbols: [\r\n          mylexer.has('number') ? { type: 'number' } : number,\r\n          { literal: '.' },\r\n          mylexer.has('number') ? { type: 'number' } : number,\r\n        ],\r\n        postprocess: (d) => ({\r\n          label: 'atom',\r\n          type: 'float',\r\n          value: d[0] + d[1] + d[2],\r\n        }),\r\n      },\r\n      { name: '_$ebnf$1', symbols: [] },\r\n      {\r\n        name: '_$ebnf$1',\r\n        symbols: ['_$ebnf$1', mylexer.has('ws') ? { type: 'ws' } : ws],\r\n        postprocess: function arrpush(d) {\r\n          return d[0].concat([d[1]]);\r\n        },\r\n      },\r\n      { name: '_', symbols: ['_$ebnf$1'] },\r\n      { name: '__$ebnf$1', symbols: [mylexer.has('ws') ? { type: 'ws' } : ws] },\r\n      {\r\n        name: '__$ebnf$1',\r\n        symbols: ['__$ebnf$1', mylexer.has('ws') ? { type: 'ws' } : ws],\r\n        postprocess: function arrpush(d) {\r\n          return d[0].concat([d[1]]);\r\n        },\r\n      },\r\n      { name: '__', symbols: ['__$ebnf$1'] },\r\n      { name: '_m$ebnf$1', symbols: [] },\r\n      {\r\n        name: '_m$ebnf$1',\r\n        symbols: ['_m$ebnf$1', mylexer.has('ws') ? { type: 'ws' } : ws],\r\n        postprocess: function arrpush(d) {\r\n          return d[0].concat([d[1]]);\r\n        },\r\n      },\r\n      {\r\n        name: '_m$subexpression$1$ebnf$1',\r\n        symbols: [mylexer.has('eol') ? { type: 'eol' } : eol],\r\n      },\r\n      {\r\n        name: '_m$subexpression$1$ebnf$1',\r\n        symbols: [\r\n          '_m$subexpression$1$ebnf$1',\r\n          mylexer.has('eol') ? { type: 'eol' } : eol,\r\n        ],\r\n        postprocess: function arrpush(d) {\r\n          return d[0].concat([d[1]]);\r\n        },\r\n      },\r\n      { name: '_m$subexpression$1', symbols: ['_m$subexpression$1$ebnf$1'] },\r\n      {\r\n        name: '_m$subexpression$1',\r\n        symbols: [mylexer.has('dedent') ? { type: 'dedent' } : dedent],\r\n      },\r\n      { name: '_m', symbols: ['_m$ebnf$1', '_m$subexpression$1'] },\r\n    ],\r\n    ParserStart: 'statements',\r\n  };\r\n  if (typeof module !== 'undefined' && typeof module.exports !== 'undefined') {\r\n    module.exports = grammar;\r\n  } else {\r\n    window.grammar = grammar;\r\n  }\r\n})();\r\nexport default grammar;\r\n","export const prefunc = `function 화면(...arg) {\r\n        console.log(...arg)\r\n      };\r\n      function 자료(...arg){\r\n       data =[...arg]\r\n      \r\n       const getV = (object, path) =>\r\n       path.reduce((result, key) => (result || {})[key], object)\r\n       let results=getV(ww,data)\r\n       \r\n       \r\n       return results\r\n      }\r\n      function 차트(label,chartdata){\r\n        keys=Object.getOwnPropertyNames(chartdata)\r\n        values=keys.map(e=>chartdata[e])\r\n        labels=label\r\n      }\r\n    `;\r\n"],"sourceRoot":""}