{"version":3,"sources":["lexer.js","generate.js","App.js","Editor.js","index.js","small.js"],"names":["indentifiedLexer","require","compile","ws","nl","match","lineBreaks","comment","number","string","iterator","operator","calculator","lparen","rparen","lbracke","rbracke","lbrace","rbrace","identifier","fatarrow","assign","keyword","module","exports","tp","node","type","statements","map","d","join","varName","var_name","value","jsExpr","funName","fun_name","arg_list","arguments","arg","has_middle_condition","has_last_statement","first_condition","first_statement","middle_condition","i","middle_statement","last_statement","arrayname","array_name","array_value","a","b","statement","console","log","nearley","grammar","generate","default","App","useState","code","setCode","parser","Parser","Grammar","fromCompiled","logs","setLogs","consoleStyles","BASE_BACKGROUND_COLOR","BASE_FONT_SIZE","LOG_ERROR_BACKGROUND","LOG_WARN_BACKGROUND","LOG_INFO_BACKGROUND","CompileandExec","feed","parserResult","results","line","lines","concat","eval","useEffect","Hook","window","currLogs","Unhook","className","onClick","language","onChange","variant","filter","styles","Editor","props","onBeforeChange","editor","data","options","lint","lineNumbers","mode","lineWrapping","theme","ReactDOM","render","StrictMode","document","getElementById","id","x","mylexer","Lexer","ParserRules","name","symbols","postprocess","label","has","literal","eol","indent","undefined","dedent","has_last_condition","v","ParserStart"],"mappings":"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","file":"static/js/main.e488c43a.chunk.js","sourcesContent":["const IndentifyLexer = require('@shieldsbetter/nearley-indentify');\r\n\r\nconst indentifiedLexer = new IndentifyLexer(mooLexer());\r\n\r\nfunction mooLexer() {\r\n  return require('moo').compile({\r\n    ws: /[ \\t]+/,\r\n    nl: { match: /\\n/, lineBreaks: true },\r\n    comment: /\\/\\/.*?$/,\r\n    number: /0|[1-9][0-9]*/,\r\n    string: /\"(?:\\\\[\"\\\\]|[^\\n\"\\\\])*\"/,\r\n    iterator: '<-',\r\n    operator: ['==', '>=', '<=', '!=', '>', '<', '.', ','],\r\n    calculator: ['+', '-', '*', '/', '++', '--'],\r\n    lparen: '(',\r\n    rparen: ')',\r\n    lbracke: '[',\r\n    rbracke: ']',\r\n    lbrace: '{',\r\n    rbrace: '}',\r\n    identifier: /[a-zA-Z가-힣][a-zA-Z가-힣_0-9]*/,\r\n    fatarrow: '=>',\r\n    assign: '=',\r\n    keyword: ['만약', '반복'],\r\n  });\r\n}\r\n\r\n/* indentifiedLexer.reset(`\r\n    Hello World\r\n        Heres some\r\n        indentation\r\n    And dedentation\r\n`);\r\n\r\nlet token = indentifiedLexer.next();\r\nwhile (token) {\r\n  console.log({ type: token.type, value: token.value });\r\n\r\n  token = indentifiedLexer.next();\r\n} */\r\n\r\nmodule.exports = indentifiedLexer;\r\n\r\n/* async function main() {\r\n  //prettier-ignore\r\n  const code = (await fs.readFile(\"ex2.small\")).toString();\r\n  lexer.reset(code);\r\n  while (true) {\r\n    const token = lexer.next();\r\n    if (!token) {\r\n      break;\r\n    }\r\n    console.log(token);\r\n  }\r\n}\r\n\r\nmain().catch((err) => console.log(err.stack)); */\r\n","function generateJsForStatements(statements) {\r\n  const lines = [];\r\n  for (let statement of statements) {\r\n    const line = tp(statement);\r\n    lines.push(line);\r\n  }\r\n  return lines.join('\\n');\r\n}\r\nfunction tp(node) {\r\n  if (node.type === 'closure') {\r\n    return `${node.statements.map((d) => tp(d)).join('\\n')}`;\r\n  } else if (node.type === 'var_assign') {\r\n    const varName = node.var_name.value;\r\n    const jsExpr = tp(node.value);\r\n    const js = `var ${varName} = ${jsExpr}`;\r\n    return js;\r\n  } else if (node.type === 'fun_call') {\r\n    const funName = node.fun_name.value;\r\n    const arg_list = node.arguments\r\n      .map((arg) => {\r\n        return tp(arg);\r\n      })\r\n      .join(',');\r\n    return `${funName}(${arg_list})`;\r\n  } else if (node.type === 'ifstate') {\r\n    if (node.has_middle_condition && node.has_last_statement) {\r\n      return `if(${tp(node.first_condition)}) {\r\n      ${tp(...node.first_statement)}}\r\n      ${node.middle_condition\r\n        .map((d, i) => `else if(${tp(d)}) {${tp(...node.middle_statement[i])}}`)\r\n        .join('\\n')}\r\n      else {${tp(...node.last_statement)}}\r\n      `;\r\n    } else if (node.has_middle_condition && !node.has_last_statement) {\r\n      return `if(${tp(node.first_condition)}) {\r\n      ${tp(...node.first_statement)}}\r\n      ${node.middle_condition\r\n        .map((d, i) => `else if(${tp(d)}) {${tp(...node.middle_statement[i])}}`)\r\n        .join('\\n')}`;\r\n    } else if (!node.has_middle_condition && node.has_last_statement) {\r\n      return `if(${tp(node.first_condition)}) {\r\n      ${tp(...node.first_statement)}}\r\n      else {${tp(...node.last_statement)}}`;\r\n    } else {\r\n      return `if(${tp(node.first_condition)}) {\r\n      ${tp(...node.first_statement)}}`;\r\n    }\r\n  } else if (node.type === 'condition') {\r\n    return node.value.map((d) => tp(d)).join('');\r\n  } else if (node.type === 'array') {\r\n    const arrayname = node.array_name.value;\r\n    return `var ${arrayname}=[${node.array_value\r\n      .map((d) => {\r\n        return tp(d);\r\n      })\r\n      .join(',')}]`;\r\n  } else if (node.type === 'for_block') {\r\n    const a = node.a.value;\r\n    const b = node.b.value;\r\n    return `for (var ${a} in ${b}) {${tp(...node.statement)} };`;\r\n  } else if (node.type === 'return') {\r\n    return node.value;\r\n  } else if (node.type === 'operator') {\r\n    return node.value;\r\n  } else if (node.type === 'string') {\r\n    return node.value;\r\n  } else if (node.type === 'number') {\r\n    return node.value;\r\n  } else if (node.type === 'identifier') {\r\n    return node.value;\r\n  } else if (node.type === 'calculator') {\r\n    return node.value;\r\n  } else {\r\n    console.log('문법이 틀렸어요...');\r\n    /* throw new Error(`unhandled ast node type 11`); */\r\n  }\r\n}\r\n\r\nexport default tp;\r\n","import Editor from './Editor.js';\nimport React, { useState, useEffect } from 'react';\nimport { Console, Hook, Unhook } from 'console-feed';\n\nconst nearley = require('nearley');\nconst grammar = require('./small.js');\nconst generate = require('./generate.js').default;\n\nfunction App() {\n  const [code, setCode] = useState('');\n  /* const [a, setA] = useState(''); */\n  const parser = new nearley.Parser(nearley.Grammar.fromCompiled(grammar));\n  const [logs, setLogs] = useState([]);\n\n  const consoleStyles = {\n    BASE_BACKGROUND_COLOR: 'none',\n    BASE_FONT_SIZE: '1.2rem',\n    LOG_ERROR_BACKGROUND: 'rgba(255,0,0,.1)',\n    LOG_WARN_BACKGROUND: 'rgba(255,255,0,.1)',\n    LOG_INFO_BACKGROUND: 'rgba(0,0,255,.1)',\n  };\n\n  useEffect(() => {\n    Hook(\n      window.console,\n      (log) => setLogs((currLogs) => [...currLogs, log]),\n      false\n    );\n    return () => Unhook(window.console);\n  }, []);\n\n  function CompileandExec() {\n    parser.feed(code);\n    const parserResult = parser.results;\n    const line = generate(parserResult[0][0]);\n    const lines = line.concat(\n      '\\n',\n      `function 화면(...arg) {\n      console.log(...arg)\n    }`\n    );\n    eval(lines);\n    /*     setA(`<html>\n      <body\n      \n      </body>\n      <script>console.log(\"a\")</script>\n    </html>`); */\n  }\n\n  return (\n    <>\n      <div className=\"panel\">\n        <h1 className=\"title\"> fitycode PLAYGROUND</h1>\n        <div className=\"left_pane\">\n          <button className=\"run_btn\" onClick={CompileandExec}>\n            RUN\n          </button>\n          <Editor language=\"javascript\" value={code} onChange={setCode} />\n        </div>\n        <div className=\"right_pane\">\n          <Console\n            logs={logs}\n            variant=\"light\"\n            filter=\"Methods[log]\"\n            styles={consoleStyles}\n          />\n          {/*    <iframe\n            srcDoc={a}\n            title=\"output\"\n            frameBorder=\"0\"\n            sandbox=\"allow-scripts\"\n            width=\"100%\"\n            height=\"100%\"\n          /> */}\n        </div>\n      </div>\n    </>\n  );\n}\n\nexport default App;\n","import React, { useState } from 'react';\r\nimport 'codemirror/lib/codemirror.css';\r\nimport 'codemirror/theme/material.css';\r\nimport 'codemirror/mode/xml/xml';\r\nimport 'codemirror/mode/javascript/javascript';\r\nimport 'codemirror/mode/css/css';\r\nimport { Controlled as ControlledEditor } from 'react-codemirror2';\r\n\r\nfunction Editor(props) {\r\n  const { language, value, onChange } = props;\r\n  function handlechange(editor, data, value) {\r\n    onChange(value);\r\n  }\r\n  return (\r\n    <>\r\n      <div className=\"editor_container\">\r\n        <ControlledEditor\r\n          className=\"editor\"\r\n          onBeforeChange={handlechange}\r\n          value={value}\r\n          options={{\r\n            lint: true,\r\n            lineNumbers: true,\r\n            mode: language,\r\n            lineWrapping: true,\r\n            theme: 'material',\r\n          }}\r\n        />\r\n      </div>\r\n    </>\r\n  );\r\n}\r\n\r\nexport default Editor;\r\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n","/* eslint-disable no-undef */\r\n// Generated automatically by nearley, version 2.19.7\r\n// http://github.com/Hardmath123/nearley\r\n(function () {\r\n  function id(x) {\r\n    return x[0];\r\n  }\r\n\r\n  const mylexer = require('./lexer');\r\n  const wrapVariable = (name) => ({\r\n    label: 'atom',\r\n    type: 'variable',\r\n    value: name,\r\n  });\r\n  var grammar = {\r\n    Lexer: mylexer,\r\n    ParserRules: [\r\n      { name: 'statements', symbols: ['closure'], postprocess: id },\r\n      { name: 'closure$ebnf$1', symbols: [] },\r\n      {\r\n        name: 'closure$ebnf$1',\r\n        symbols: ['closure$ebnf$1', 'statement'],\r\n        postprocess: function arrpush(d) {\r\n          return d[0].concat([d[1]]);\r\n        },\r\n      },\r\n      {\r\n        name: 'closure',\r\n        symbols: ['closure$ebnf$1'],\r\n        postprocess: (data) => [\r\n          {\r\n            label: 'closure',\r\n            type: 'closure',\r\n            statements: data[0],\r\n          },\r\n        ],\r\n      },\r\n      { name: 'statement', symbols: ['var_assign', '_m'], postprocess: id },\r\n      { name: 'statement', symbols: ['fun_call', '_m'], postprocess: id },\r\n      { name: 'statement', symbols: ['if_state', '_m'], postprocess: id },\r\n      { name: 'statement', symbols: ['for_state', '_m'], postprocess: id },\r\n      { name: 'statement', symbols: ['return', '_m'], postprocess: id },\r\n      {\r\n        name: 'var_assign',\r\n        symbols: [\r\n          mylexer.has('identifier') ? { type: 'identifier' } : identifier,\r\n          '_',\r\n          { literal: '=' },\r\n          '_',\r\n          'expr',\r\n        ],\r\n        postprocess: (data) => {\r\n          return {\r\n            label: 'state',\r\n            type: 'var_assign',\r\n            var_name: data[0],\r\n            value: data[4],\r\n          };\r\n        },\r\n      },\r\n      {\r\n        name: 'var_assign',\r\n        symbols: [\r\n          mylexer.has('identifier') ? { type: 'identifier' } : identifier,\r\n          '_',\r\n          { literal: '=' },\r\n          '_',\r\n          'array',\r\n        ],\r\n        postprocess: (data) => {\r\n          return {\r\n            label: 'state',\r\n            type: 'array',\r\n            array_name: data[0],\r\n            array_value: data[4],\r\n          };\r\n        },\r\n      },\r\n      { name: 'fun_call$ebnf$1$subexpression$1', symbols: ['arg_list', '_'] },\r\n      {\r\n        name: 'fun_call$ebnf$1',\r\n        symbols: ['fun_call$ebnf$1$subexpression$1'],\r\n        postprocess: id,\r\n      },\r\n      {\r\n        name: 'fun_call$ebnf$1',\r\n        symbols: [],\r\n        postprocess: function (d) {\r\n          return null;\r\n        },\r\n      },\r\n      {\r\n        name: 'fun_call',\r\n        symbols: [\r\n          mylexer.has('identifier') ? { type: 'identifier' } : identifier,\r\n          '_',\r\n          { literal: '(' },\r\n          '_',\r\n          'fun_call$ebnf$1',\r\n          { literal: ')' },\r\n        ],\r\n        postprocess: (data) => {\r\n          return {\r\n            label: 'state',\r\n            type: 'fun_call',\r\n            fun_name: data[0],\r\n            arguments: data[4] ? data[4][0] : [],\r\n          };\r\n        },\r\n      },\r\n      {\r\n        name: 'if_state',\r\n        symbols: [\r\n          { literal: '만약' },\r\n          '_',\r\n          'condition',\r\n          mylexer.has('eol') ? { type: 'eol' } : eol,\r\n          mylexer.has('indent') ? { type: 'indent' } : indent,\r\n          'closure',\r\n        ],\r\n        postprocess: (data) => {\r\n          return {\r\n            label: 'state',\r\n            type: 'ifstate',\r\n            first_condition: data[2],\r\n            first_statement: [...data[5]],\r\n\r\n            has_middle_condition: false,\r\n            middle_statement: undefined,\r\n\r\n            has_last_statement: false,\r\n            last_statement: undefined,\r\n          };\r\n        },\r\n      },\r\n      {\r\n        name: 'if_state',\r\n        symbols: [\r\n          { literal: '만약' },\r\n          '_',\r\n          'condition',\r\n          mylexer.has('eol') ? { type: 'eol' } : eol,\r\n          mylexer.has('indent') ? { type: 'indent' } : indent,\r\n          'closure',\r\n          mylexer.has('dedent') ? { type: 'dedent' } : dedent,\r\n          { literal: '거짓' },\r\n          '_',\r\n          mylexer.has('eol') ? { type: 'eol' } : eol,\r\n          mylexer.has('indent') ? { type: 'indent' } : indent,\r\n          'closure',\r\n        ],\r\n        postprocess: (data) => {\r\n          return {\r\n            label: 'state',\r\n            type: 'ifstate',\r\n            first_condition: data[2],\r\n            first_statement: data[5],\r\n\r\n            has_middle_condition: false,\r\n            middle_statement: undefined,\r\n\r\n            has_last_statement: true,\r\n            last_statement: [...data[11]],\r\n          };\r\n        },\r\n      },\r\n      { name: 'if_state$ebnf$1', symbols: [] },\r\n      {\r\n        name: 'if_state$ebnf$1$subexpression$1',\r\n        symbols: [\r\n          { literal: '아니면' },\r\n          '_',\r\n          'condition',\r\n          mylexer.has('eol') ? { type: 'eol' } : eol,\r\n          mylexer.has('indent') ? { type: 'indent' } : indent,\r\n          'closure',\r\n          mylexer.has('dedent') ? { type: 'dedent' } : dedent,\r\n        ],\r\n      },\r\n      {\r\n        name: 'if_state$ebnf$1',\r\n        symbols: ['if_state$ebnf$1', 'if_state$ebnf$1$subexpression$1'],\r\n        postprocess: function arrpush(d) {\r\n          return d[0].concat([d[1]]);\r\n        },\r\n      },\r\n      {\r\n        name: 'if_state',\r\n        symbols: [\r\n          { literal: '만약' },\r\n          '_',\r\n          'condition',\r\n          mylexer.has('eol') ? { type: 'eol' } : eol,\r\n          mylexer.has('indent') ? { type: 'indent' } : indent,\r\n          'closure',\r\n          mylexer.has('dedent') ? { type: 'dedent' } : dedent,\r\n          'if_state$ebnf$1',\r\n          { literal: '아니면' },\r\n          '_',\r\n          'condition',\r\n          mylexer.has('eol') ? { type: 'eol' } : eol,\r\n          mylexer.has('indent') ? { type: 'indent' } : indent,\r\n          'closure',\r\n        ],\r\n        postprocess: (data) => {\r\n          return {\r\n            label: 'state',\r\n            type: 'ifstate',\r\n            first_condition: data[2],\r\n            first_statement: data[5],\r\n\r\n            has_middle_condition: true,\r\n            middle_condition: [...data[7].map((value) => value[2]), data[10]],\r\n            middle_statement: [...data[7].map((value) => value[5]), data[13]],\r\n\r\n            has_last_condition: false,\r\n            last_statement: undefined,\r\n          };\r\n        },\r\n      },\r\n      {\r\n        name: 'if_state$ebnf$2$subexpression$1',\r\n        symbols: [\r\n          { literal: '아니면' },\r\n          '_',\r\n          'condition',\r\n          mylexer.has('eol') ? { type: 'eol' } : eol,\r\n          mylexer.has('indent') ? { type: 'indent' } : indent,\r\n          'closure',\r\n          mylexer.has('dedent') ? { type: 'dedent' } : dedent,\r\n        ],\r\n      },\r\n      { name: 'if_state$ebnf$2', symbols: ['if_state$ebnf$2$subexpression$1'] },\r\n      {\r\n        name: 'if_state$ebnf$2$subexpression$2',\r\n        symbols: [\r\n          { literal: '아니면' },\r\n          '_',\r\n          'condition',\r\n          mylexer.has('eol') ? { type: 'eol' } : eol,\r\n          mylexer.has('indent') ? { type: 'indent' } : indent,\r\n          'closure',\r\n          mylexer.has('dedent') ? { type: 'dedent' } : dedent,\r\n        ],\r\n      },\r\n      {\r\n        name: 'if_state$ebnf$2',\r\n        symbols: ['if_state$ebnf$2', 'if_state$ebnf$2$subexpression$2'],\r\n        postprocess: function arrpush(d) {\r\n          return d[0].concat([d[1]]);\r\n        },\r\n      },\r\n      {\r\n        name: 'if_state',\r\n        symbols: [\r\n          { literal: '만약' },\r\n          '_',\r\n          'condition',\r\n          mylexer.has('eol') ? { type: 'eol' } : eol,\r\n          mylexer.has('indent') ? { type: 'indent' } : indent,\r\n          'closure',\r\n          mylexer.has('dedent') ? { type: 'dedent' } : dedent,\r\n          'if_state$ebnf$2',\r\n          { literal: '거짓' },\r\n          '_',\r\n          mylexer.has('eol') ? { type: 'eol' } : eol,\r\n          mylexer.has('indent') ? { type: 'indent' } : indent,\r\n          'closure',\r\n        ],\r\n        postprocess: (data) => {\r\n          return {\r\n            label: 'state',\r\n            type: 'ifstate',\r\n            first_condition: data[2],\r\n            first_statement: data[5],\r\n\r\n            has_middle_condition: true,\r\n            middle_condition: [...data[7].map((value) => value[2])],\r\n            middle_statement: [...data[7].map((value) => value[5])],\r\n\r\n            has_last_statement: true,\r\n            last_statement: [...data[12]],\r\n          };\r\n        },\r\n      },\r\n      {\r\n        name: 'condition',\r\n        symbols: [\r\n          'expr',\r\n          '_',\r\n          mylexer.has('operator') ? { type: 'operator' } : operator,\r\n          '_',\r\n          'expr',\r\n        ],\r\n        postprocess: (data) => {\r\n          return {\r\n            type: 'condition',\r\n            value: [data[0], data[2], data[4]],\r\n          };\r\n        },\r\n      },\r\n      {\r\n        name: 'arg_list',\r\n        symbols: ['expr'],\r\n        postprocess: (data) => {\r\n          return [data[0]];\r\n        },\r\n      },\r\n      {\r\n        name: 'arg_list',\r\n        symbols: ['arg_list', '__', 'expr'],\r\n        postprocess: (data) => {\r\n          return [...data[0], data[2]];\r\n        },\r\n      },\r\n      { name: 'array$ebnf$1', symbols: [] },\r\n      {\r\n        name: 'array$ebnf$1$subexpression$1',\r\n        symbols: [{ literal: ',' }, '_', 'expr'],\r\n      },\r\n      {\r\n        name: 'array$ebnf$1',\r\n        symbols: ['array$ebnf$1', 'array$ebnf$1$subexpression$1'],\r\n        postprocess: function arrpush(d) {\r\n          return d[0].concat([d[1]]);\r\n        },\r\n      },\r\n      {\r\n        name: 'array',\r\n        symbols: [\r\n          { literal: '[' },\r\n          '_',\r\n          'expr',\r\n          '_',\r\n          'array$ebnf$1',\r\n          '_',\r\n          { literal: ']' },\r\n        ],\r\n        postprocess: (data) => {\r\n          return [data[2], ...data[4].map((v) => v[2])];\r\n        },\r\n      },\r\n      {\r\n        name: 'expr',\r\n        symbols: [mylexer.has('string') ? { type: 'string' } : string],\r\n        postprocess: id,\r\n      },\r\n      {\r\n        name: 'expr',\r\n        symbols: [\r\n          mylexer.has('identifier') ? { type: 'identifier' } : identifier,\r\n        ],\r\n        postprocess: id,\r\n      },\r\n      { name: 'expr', symbols: ['fun_call'], postprocess: id },\r\n      { name: 'expr', symbols: ['AS'], postprocess: id },\r\n      {\r\n        name: 'for_state',\r\n        symbols: [\r\n          { literal: '반복' },\r\n          '__',\r\n          'expr',\r\n          '_',\r\n          mylexer.has('iterator') ? { type: 'iterator' } : iterator,\r\n          '_',\r\n          'expr',\r\n          mylexer.has('eol') ? { type: 'eol' } : eol,\r\n          mylexer.has('indent') ? { type: 'indent' } : indent,\r\n          'closure',\r\n        ],\r\n        postprocess: (data) => {\r\n          return {\r\n            label: 'statement',\r\n            type: 'for_block',\r\n            a: data[2],\r\n            iterator: data[4],\r\n            b: data[6],\r\n            statement: data[9],\r\n          };\r\n        },\r\n      },\r\n      {\r\n        name: 'return',\r\n        symbols: [{ literal: '출력' }, '_', 'expr'],\r\n        postprocess: (d) => {\r\n          return { type: 'return', value: d[2] };\r\n        },\r\n      },\r\n      {\r\n        name: 'P',\r\n        symbols: [{ literal: '(' }, '_', 'AS', '_', { literal: ')' }],\r\n        postprocess: (d) => {\r\n          return d[2];\r\n        },\r\n      },\r\n      { name: 'P', symbols: ['number'], postprocess: id },\r\n      { name: 'MD', symbols: ['P'], postprocess: id },\r\n      {\r\n        name: 'MD',\r\n        symbols: ['MD', '_', { literal: '*' }, '_', 'P'],\r\n        postprocess: (d) => {\r\n          return [d[0], d[2], d[4]];\r\n        },\r\n      },\r\n      {\r\n        name: 'MD',\r\n        symbols: ['MD', '_', { literal: '/' }, '_', 'P'],\r\n        postprocess: (d) => {\r\n          return [d[0], d[2], d[4]];\r\n        },\r\n      },\r\n      { name: 'AS', symbols: ['MD'], postprocess: id },\r\n      {\r\n        name: 'AS',\r\n        symbols: ['AS', '_', { literal: '+' }, '_', 'MD'],\r\n        postprocess: (d) => {\r\n          return [d[0], d[2], d[4]];\r\n        },\r\n      },\r\n      {\r\n        name: 'AS',\r\n        symbols: ['AS', '_', { literal: '-' }, '_', 'MD'],\r\n        postprocess: (d) => {\r\n          return [d[0], d[2], d[4]];\r\n        },\r\n      },\r\n      {\r\n        name: 'cal',\r\n        symbols: [\r\n          mylexer.has('calculator') ? { type: 'calculator' } : calculator,\r\n        ],\r\n        postprocess: id,\r\n      },\r\n      {\r\n        name: 'number',\r\n        symbols: [mylexer.has('number') ? { type: 'number' } : number],\r\n        postprocess: id,\r\n      },\r\n      { name: 'number', symbols: ['float'], postprocess: id },\r\n      {\r\n        name: 'float',\r\n        symbols: [\r\n          mylexer.has('number') ? { type: 'number' } : number,\r\n          { literal: '.' },\r\n          mylexer.has('number') ? { type: 'number' } : number,\r\n        ],\r\n        postprocess: (d) => ({\r\n          label: 'atom',\r\n          type: 'float',\r\n          value: d[0] + d[1] + d[2],\r\n        }),\r\n      },\r\n      { name: '_$ebnf$1', symbols: [] },\r\n      {\r\n        name: '_$ebnf$1',\r\n        symbols: ['_$ebnf$1', mylexer.has('ws') ? { type: 'ws' } : ws],\r\n        postprocess: function arrpush(d) {\r\n          return d[0].concat([d[1]]);\r\n        },\r\n      },\r\n      { name: '_', symbols: ['_$ebnf$1'] },\r\n      { name: '__$ebnf$1', symbols: [mylexer.has('ws') ? { type: 'ws' } : ws] },\r\n      {\r\n        name: '__$ebnf$1',\r\n        symbols: ['__$ebnf$1', mylexer.has('ws') ? { type: 'ws' } : ws],\r\n        postprocess: function arrpush(d) {\r\n          return d[0].concat([d[1]]);\r\n        },\r\n      },\r\n      { name: '__', symbols: ['__$ebnf$1'] },\r\n      { name: '_m$ebnf$1', symbols: [] },\r\n      {\r\n        name: '_m$ebnf$1',\r\n        symbols: ['_m$ebnf$1', mylexer.has('ws') ? { type: 'ws' } : ws],\r\n        postprocess: function arrpush(d) {\r\n          return d[0].concat([d[1]]);\r\n        },\r\n      },\r\n      {\r\n        name: '_m$subexpression$1$ebnf$1',\r\n        symbols: [mylexer.has('eol') ? { type: 'eol' } : eol],\r\n      },\r\n      {\r\n        name: '_m$subexpression$1$ebnf$1',\r\n        symbols: [\r\n          '_m$subexpression$1$ebnf$1',\r\n          mylexer.has('eol') ? { type: 'eol' } : eol,\r\n        ],\r\n        postprocess: function arrpush(d) {\r\n          return d[0].concat([d[1]]);\r\n        },\r\n      },\r\n      { name: '_m$subexpression$1', symbols: ['_m$subexpression$1$ebnf$1'] },\r\n      {\r\n        name: '_m$subexpression$1',\r\n        symbols: [mylexer.has('dedent') ? { type: 'dedent' } : dedent],\r\n      },\r\n      { name: '_m', symbols: ['_m$ebnf$1', '_m$subexpression$1'] },\r\n    ],\r\n    ParserStart: 'statements',\r\n  };\r\n  if (typeof module !== 'undefined' && typeof module.exports !== 'undefined') {\r\n    module.exports = grammar;\r\n  } else {\r\n    window.grammar = grammar;\r\n  }\r\n})();\r\n"],"sourceRoot":""}